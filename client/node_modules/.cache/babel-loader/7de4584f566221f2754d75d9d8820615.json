{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/modifyselection\n */\nimport Position from '../position';\nimport TreeWalker from '../treewalker';\nimport Range from '../range';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol, isInsideEmojiSequence } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport DocumentSelection from '../documentselection';\nconst wordBoundaryCharacters = ' ,.?!:;\"-()';\n/**\n * Modifies the selection. Currently, the supported modifications are:\n *\n * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n * Possible values for `unit` are:\n *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n *  why `'character'` value is most natural and common method of modifying selection.\n *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n *  extension will include whole \"surrogate pair\".\n *  * `'word'` - moves selection by a whole word.\n *\n * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n *\n * **Note:** Use {@link module:engine/model/model~Model#modifySelection} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#modifySelection}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection to modify.\n * @param {Object} [options]\n * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n * @param {Boolean} [options.treatEmojiAsSingleUnit=false] Whether multi-characer emoji sequences should be handled as single unit.\n */\n\nexport default function modifySelection(model, selection) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const schema = model.schema;\n  const isForward = options.direction != 'backward';\n  const unit = options.unit ? options.unit : 'character';\n  const treatEmojiAsSingleUnit = !!options.treatEmojiAsSingleUnit;\n  const focus = selection.focus;\n  const walker = new TreeWalker({\n    boundaries: getSearchRange(focus, isForward),\n    singleCharacters: true,\n    direction: isForward ? 'forward' : 'backward'\n  });\n  const data = {\n    walker,\n    schema,\n    isForward,\n    unit,\n    treatEmojiAsSingleUnit\n  };\n  let next;\n\n  while (next = walker.next()) {\n    if (next.done) {\n      return;\n    }\n\n    const position = tryExtendingTo(data, next.value);\n\n    if (position) {\n      if (selection instanceof DocumentSelection) {\n        model.change(writer => {\n          writer.setSelectionFocus(position);\n        });\n      } else {\n        selection.setFocus(position);\n      }\n\n      return;\n    }\n  }\n} // Checks whether the selection can be extended to the the walker's next value (next position).\n// @param {{ walker, unit, isForward, schema, treatEmojiAsSingleUnit }} data\n// @param {module:engine/view/treewalker~TreeWalkerValue} value\n\nfunction tryExtendingTo(data, value) {\n  const {\n    isForward,\n    walker,\n    unit,\n    schema,\n    treatEmojiAsSingleUnit\n  } = data;\n  const {\n    type,\n    item,\n    nextPosition\n  } = value; // If found text, we can certainly put the focus in it. Let's just find a correct position\n  // based on the unit.\n\n  if (type == 'text') {\n    if (data.unit === 'word') {\n      return getCorrectWordBreakPosition(walker, isForward);\n    }\n\n    return getCorrectPosition(walker, unit, treatEmojiAsSingleUnit);\n  } // Entering an element.\n\n\n  if (type == (isForward ? 'elementStart' : 'elementEnd')) {\n    // If it's a selectable, we can select it now.\n    if (schema.isSelectable(item)) {\n      return Position._createAt(item, isForward ? 'after' : 'before');\n    } // If text allowed on this position, extend to this place.\n\n\n    if (schema.checkChild(nextPosition, '$text')) {\n      return nextPosition;\n    }\n  } // Leaving an element.\n  else {\n    // If leaving a limit element, stop.\n    if (schema.isLimit(item)) {\n      // NOTE: Fast-forward the walker until the end.\n      walker.skip(() => true);\n      return;\n    } // If text allowed on this position, extend to this place.\n\n\n    if (schema.checkChild(nextPosition, '$text')) {\n      return nextPosition;\n    }\n  }\n} // Finds a correct position by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {String} unit The unit by which selection should be modified.\n// @param {Boolean} treatEmojiAsSingleUnit\n\n\nfunction getCorrectPosition(walker, unit, treatEmojiAsSingleUnit) {\n  const textNode = walker.position.textNode;\n\n  if (textNode) {\n    const data = textNode.data;\n    let offset = walker.position.offset - textNode.startOffset;\n\n    while (isInsideSurrogatePair(data, offset) || unit == 'character' && isInsideCombinedSymbol(data, offset) || treatEmojiAsSingleUnit && isInsideEmojiSequence(data, offset)) {\n      walker.next();\n      offset = walker.position.offset - textNode.startOffset;\n    }\n  }\n\n  return walker.position;\n} // Finds a correct position of a word break by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\n\n\nfunction getCorrectWordBreakPosition(walker, isForward) {\n  let textNode = walker.position.textNode;\n\n  if (textNode) {\n    let offset = walker.position.offset - textNode.startOffset;\n\n    while (!isAtWordBoundary(textNode.data, offset, isForward) && !isAtNodeBoundary(textNode, offset, isForward)) {\n      walker.next(); // Check of adjacent text nodes with different attributes (like BOLD).\n      // Example          : 'foofoo []bar<$text bold=\"true\">bar</$text> bazbaz'\n      // should expand to : 'foofoo [bar<$text bold=\"true\">bar</$text>] bazbaz'.\n\n      const nextNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore; // Scan only text nodes. Ignore inline elements (like `<softBreak>`).\n\n      if (nextNode && nextNode.is('$text')) {\n        // Check boundary char of an adjacent text node.\n        const boundaryChar = nextNode.data.charAt(isForward ? 0 : nextNode.data.length - 1); // Go to the next node if the character at the boundary of that node belongs to the same word.\n\n        if (!wordBoundaryCharacters.includes(boundaryChar)) {\n          // If adjacent text node belongs to the same word go to it & reset values.\n          walker.next();\n          textNode = walker.position.textNode;\n        }\n      }\n\n      offset = walker.position.offset - textNode.startOffset;\n    }\n  }\n\n  return walker.position;\n}\n\nfunction getSearchRange(start, isForward) {\n  const root = start.root;\n\n  const searchEnd = Position._createAt(root, isForward ? 'end' : 0);\n\n  if (isForward) {\n    return new Range(start, searchEnd);\n  } else {\n    return new Range(searchEnd, start);\n  }\n} // Checks if selection is on word boundary.\n//\n// @param {String} data The text node value to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\n\n\nfunction isAtWordBoundary(data, offset, isForward) {\n  // The offset to check depends on direction.\n  const offsetToCheck = offset + (isForward ? 0 : -1);\n  return wordBoundaryCharacters.includes(data.charAt(offsetToCheck));\n} // Checks if selection is on node boundary.\n//\n// @param {module:engine/model/text~Text} textNode The text node to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\n\n\nfunction isAtNodeBoundary(textNode, offset, isForward) {\n  return offset === (isForward ? textNode.endOffset : 0);\n}","map":{"version":3,"sources":["C:/Users/Hp/OneDrive/Desktop/reddit-clone/client/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/modifyselection.js"],"names":["Position","TreeWalker","Range","isInsideSurrogatePair","isInsideCombinedSymbol","isInsideEmojiSequence","DocumentSelection","wordBoundaryCharacters","modifySelection","model","selection","options","schema","isForward","direction","unit","treatEmojiAsSingleUnit","focus","walker","boundaries","getSearchRange","singleCharacters","data","next","done","position","tryExtendingTo","value","change","writer","setSelectionFocus","setFocus","type","item","nextPosition","getCorrectWordBreakPosition","getCorrectPosition","isSelectable","_createAt","checkChild","isLimit","skip","textNode","offset","startOffset","isAtWordBoundary","isAtNodeBoundary","nextNode","nodeAfter","nodeBefore","is","boundaryChar","charAt","length","includes","start","root","searchEnd","offsetToCheck","endOffset"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/modifyselection\n */\n\nimport Position from '../position';\nimport TreeWalker from '../treewalker';\nimport Range from '../range';\nimport { isInsideSurrogatePair, isInsideCombinedSymbol, isInsideEmojiSequence } from '@ckeditor/ckeditor5-utils/src/unicode';\nimport DocumentSelection from '../documentselection';\n\nconst wordBoundaryCharacters = ' ,.?!:;\"-()';\n\n/**\n * Modifies the selection. Currently, the supported modifications are:\n *\n * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n * Possible values for `unit` are:\n *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n *  why `'character'` value is most natural and common method of modifying selection.\n *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n *  extension will include whole \"surrogate pair\".\n *  * `'word'` - moves selection by a whole word.\n *\n * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n *\n * **Note:** Use {@link module:engine/model/model~Model#modifySelection} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#modifySelection}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which\n * the selection modification should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection to modify.\n * @param {Object} [options]\n * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n * @param {Boolean} [options.treatEmojiAsSingleUnit=false] Whether multi-characer emoji sequences should be handled as single unit.\n */\nexport default function modifySelection( model, selection, options = {} ) {\n\tconst schema = model.schema;\n\tconst isForward = options.direction != 'backward';\n\tconst unit = options.unit ? options.unit : 'character';\n\tconst treatEmojiAsSingleUnit = !!options.treatEmojiAsSingleUnit;\n\n\tconst focus = selection.focus;\n\n\tconst walker = new TreeWalker( {\n\t\tboundaries: getSearchRange( focus, isForward ),\n\t\tsingleCharacters: true,\n\t\tdirection: isForward ? 'forward' : 'backward'\n\t} );\n\n\tconst data = { walker, schema, isForward, unit, treatEmojiAsSingleUnit };\n\n\tlet next;\n\n\twhile ( ( next = walker.next() ) ) {\n\t\tif ( next.done ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst position = tryExtendingTo( data, next.value );\n\n\t\tif ( position ) {\n\t\t\tif ( selection instanceof DocumentSelection ) {\n\t\t\t\tmodel.change( writer => {\n\t\t\t\t\twriter.setSelectionFocus( position );\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\tselection.setFocus( position );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n// Checks whether the selection can be extended to the the walker's next value (next position).\n// @param {{ walker, unit, isForward, schema, treatEmojiAsSingleUnit }} data\n// @param {module:engine/view/treewalker~TreeWalkerValue} value\nfunction tryExtendingTo( data, value ) {\n\tconst { isForward, walker, unit, schema, treatEmojiAsSingleUnit } = data;\n\tconst { type, item, nextPosition } = value;\n\n\t// If found text, we can certainly put the focus in it. Let's just find a correct position\n\t// based on the unit.\n\tif ( type == 'text' ) {\n\t\tif ( data.unit === 'word' ) {\n\t\t\treturn getCorrectWordBreakPosition( walker, isForward );\n\t\t}\n\n\t\treturn getCorrectPosition( walker, unit, treatEmojiAsSingleUnit );\n\t}\n\n\t// Entering an element.\n\tif ( type == ( isForward ? 'elementStart' : 'elementEnd' ) ) {\n\t\t// If it's a selectable, we can select it now.\n\t\tif ( schema.isSelectable( item ) ) {\n\t\t\treturn Position._createAt( item, isForward ? 'after' : 'before' );\n\t\t}\n\n\t\t// If text allowed on this position, extend to this place.\n\t\tif ( schema.checkChild( nextPosition, '$text' ) ) {\n\t\t\treturn nextPosition;\n\t\t}\n\t}\n\t// Leaving an element.\n\telse {\n\t\t// If leaving a limit element, stop.\n\t\tif ( schema.isLimit( item ) ) {\n\t\t\t// NOTE: Fast-forward the walker until the end.\n\t\t\twalker.skip( () => true );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// If text allowed on this position, extend to this place.\n\t\tif ( schema.checkChild( nextPosition, '$text' ) ) {\n\t\t\treturn nextPosition;\n\t\t}\n\t}\n}\n\n// Finds a correct position by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {String} unit The unit by which selection should be modified.\n// @param {Boolean} treatEmojiAsSingleUnit\nfunction getCorrectPosition( walker, unit, treatEmojiAsSingleUnit ) {\n\tconst textNode = walker.position.textNode;\n\n\tif ( textNode ) {\n\t\tconst data = textNode.data;\n\t\tlet offset = walker.position.offset - textNode.startOffset;\n\n\t\twhile (\n\t\t\tisInsideSurrogatePair( data, offset ) ||\n\t\t\t( unit == 'character' && isInsideCombinedSymbol( data, offset ) ) ||\n\t\t\t( treatEmojiAsSingleUnit && isInsideEmojiSequence( data, offset ) )\n\t\t) {\n\t\t\twalker.next();\n\n\t\t\toffset = walker.position.offset - textNode.startOffset;\n\t\t}\n\t}\n\n\treturn walker.position;\n}\n\n// Finds a correct position of a word break by walking in a text node and checking whether selection can be extended to given position\n// or should be extended further.\n//\n// @param {module:engine/model/treewalker~TreeWalker} walker\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction getCorrectWordBreakPosition( walker, isForward ) {\n\tlet textNode = walker.position.textNode;\n\n\tif ( textNode ) {\n\t\tlet offset = walker.position.offset - textNode.startOffset;\n\n\t\twhile ( !isAtWordBoundary( textNode.data, offset, isForward ) && !isAtNodeBoundary( textNode, offset, isForward ) ) {\n\t\t\twalker.next();\n\n\t\t\t// Check of adjacent text nodes with different attributes (like BOLD).\n\t\t\t// Example          : 'foofoo []bar<$text bold=\"true\">bar</$text> bazbaz'\n\t\t\t// should expand to : 'foofoo [bar<$text bold=\"true\">bar</$text>] bazbaz'.\n\t\t\tconst nextNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;\n\n\t\t\t// Scan only text nodes. Ignore inline elements (like `<softBreak>`).\n\t\t\tif ( nextNode && nextNode.is( '$text' ) ) {\n\t\t\t\t// Check boundary char of an adjacent text node.\n\t\t\t\tconst boundaryChar = nextNode.data.charAt( isForward ? 0 : nextNode.data.length - 1 );\n\n\t\t\t\t// Go to the next node if the character at the boundary of that node belongs to the same word.\n\t\t\t\tif ( !wordBoundaryCharacters.includes( boundaryChar ) ) {\n\t\t\t\t\t// If adjacent text node belongs to the same word go to it & reset values.\n\t\t\t\t\twalker.next();\n\n\t\t\t\t\ttextNode = walker.position.textNode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toffset = walker.position.offset - textNode.startOffset;\n\t\t}\n\t}\n\n\treturn walker.position;\n}\n\nfunction getSearchRange( start, isForward ) {\n\tconst root = start.root;\n\tconst searchEnd = Position._createAt( root, isForward ? 'end' : 0 );\n\n\tif ( isForward ) {\n\t\treturn new Range( start, searchEnd );\n\t} else {\n\t\treturn new Range( searchEnd, start );\n\t}\n}\n\n// Checks if selection is on word boundary.\n//\n// @param {String} data The text node value to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction isAtWordBoundary( data, offset, isForward ) {\n\t// The offset to check depends on direction.\n\tconst offsetToCheck = offset + ( isForward ? 0 : -1 );\n\n\treturn wordBoundaryCharacters.includes( data.charAt( offsetToCheck ) );\n}\n\n// Checks if selection is on node boundary.\n//\n// @param {module:engine/model/text~Text} textNode The text node to investigate.\n// @param {Number} offset Position offset.\n// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.\nfunction isAtNodeBoundary( textNode, offset, isForward ) {\n\treturn offset === ( isForward ? textNode.endOffset : 0 );\n}\n"]},"metadata":{},"sourceType":"module"}